# Set up imports which are required
import sys
import numpy as np
import matplotlib.pyplot as plt

# Function to calculate the distance between the cities
def calculate_distance(city1, city2):
    x1, y1 = city1
    x2, y2 = city2
    return ((x2-x1)**2 + (y2-y1)**2)**0.5

# Function to calculate the total distance required to visit the cities in the given order
def distance(cities, cityorder):
    totaldistance = 0
    for i in range(len(cityorder)):
        totaldistance += calculate_distance(cities[cityorder[i-1]], cities[cityorder[i]])
    return totaldistance

# Function which implements simulated annealing algorithm to find the shortest possible route 
def tsp(cities):

    # Generating a random order and calculating total distance
    current_order = list(range(len(cities)))
    current_distance = distance(cities,current_order)

    # Assigning the best order to be current order and it gets updated if it finds a better path
    best_order = current_order.copy()
    best_distance = current_distance

    # temp is set to be 100 with the decay rate of 0.99
    temp,rate = 100,0.99

    # Iterating until temp reaches 5e-9, 
    while temp > 5e-9:

        new_order = current_order.copy()

        # A new order is generated by reversing a random segment of the current order
        i,j = sorted(np.random.choice(range(len(cities)), 2))
        new_order[i:j+1] = reversed(new_order[i:j+1])
        new_distance = distance(cities,new_order)

        delta_distance = new_distance - current_distance

        # Choosing any random number between 0 and 1
        toss = np.random.random_sample()

        # Updating the path is done according to the conditions used 
        if delta_distance < 0 or toss < np.exp(-delta_distance / temp):
            current_order = new_order
            current_distance = new_distance
            if current_distance < best_distance:
                best_order = current_order
                best_distance = current_distance
        temp *= rate
    return best_order

# Extracting the data from the input file
f = open(sys.argv[1],'r')
cities = []
for line in f:
    if len(line.split())!=1:
        cities.append((float(line.split()[0]),float(line.split()[1])))
f.close()

x_cities, y_cities = zip(*cities)
random_order = np.arange(len(cities))

# Generating a random order and plotting its path
np.random.shuffle(random_order)
x_random = np.array(x_cities)[random_order]
y_random = np.array(y_cities)[random_order]
x_random = np.append(x_random,x_random[0])
y_random = np.append(y_random,y_random[0])
random_distance = distance(cities,random_order)
print(f"City order for random path: {list(random_order)}")
print(f"Total Distance for random order: {random_distance}")
plt.scatter([x_random[0]],[y_random[0]],s=100,color='r',label="Starting Point")
plt.plot(x_random,y_random,marker='o',ms=5,label="Random path")
plt.title("Total Distance covered: "+str(random_distance))
plt.legend()
plt.show()

# Generating the city order using the algorithm used and plotting its path
cityorder = tsp(cities)
xplot = np.array(x_cities)[cityorder]
yplot = np.array(y_cities)[cityorder]
xplot = np.append(xplot, xplot[0])
yplot = np.append(yplot, yplot[0])
totaldistance = distance(cities, cityorder)
print(f"City order for shortest path: {cityorder}")
print(f"Total Distance for shortest path: {totaldistance}")
plt.scatter([xplot[0]],[yplot[0]],s=100,color='r',label="Starting point")
plt.plot(xplot, yplot, marker='o', label='Shortest Path',ms=5)
plt.title("Total Distance covered: "+str(totaldistance))
plt.legend()
plt.show()

# Percentage Improvement in the total distance
percent_improvement = ((random_distance-totaldistance)/random_distance)*100
print(f"Percentage Improvement: {percent_improvement:.2f}%")